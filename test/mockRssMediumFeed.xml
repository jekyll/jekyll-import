<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"
     xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Suman Maity on Medium]]></title>
        <description><![CDATA[Stories by Suman Maity on Medium]]></description>
        <link>https://medium.com/@suman.maity112?source=rss-92eeb3145de9------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*rAk1Q7-7kFOM-arRqtpvMA.jpeg</url>
            <title>Stories by Suman Maity on Medium</title>
            <link>https://medium.com/@suman.maity112?source=rss-92eeb3145de9------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 05 Dec 2022 17:45:48 GMT</lastBuildDate>
        <atom:link href="https://medium.com/@suman.maity112/feed" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[How to reduce JVM docker image size by at least 60%]]></title>
            <link>
                https://blog.devops.dev/how-to-reduce-jvm-docker-image-size-by-at-least-60-459ec87b95d8?source=rss-92eeb3145de9------2
            </link>
            <guid isPermaLink="false">https://medium.com/p/459ec87b95d8</guid>
            <category><![CDATA[java]]></category>
            <category><![CDATA[custom-jre]]></category>
            <category><![CDATA[image-size-reduce]]></category>
            <category><![CDATA[jvm]]></category>
            <category><![CDATA[docker]]></category>
            <dc:creator><![CDATA[Suman Maity]]></dc:creator>
            <pubDate>Tue, 22 Nov 2022 08:01:46 GMT</pubDate>
            <atom:updated>2022-11-23T14:51:57.412Z</atom:updated>
            <content:encoded>
                <![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cR9eGZr50HArf_j9-rnjjQ.png" /></figure><p>If you’ve been working with JVM-based languages (Java, Kotlin, Scala, and so on) for a while, you may have noticed that, beginning with Java 11, the Java Runtime Environment (JRE) no longer has a separate distribution. Because of this decision, many Java Development Kit (JDK) docker image distributors, such as <a href="https://hub.docker.com/_/openjdk">OpenJDK</a>, <a href="https://hub.docker.com/_/amazoncorretto">Amazon Correto</a>, and others, do not provide JRE as a separate docker image. Using these images resulted in an overall Docker image size of about 360 MB, while the actual application jar size was about 26 MB. The overall Docker image size is too large in my opinion, and it should be reduced in order to save space and network bandwidth for everyone who will use this Docker image. Now, let’s see how to drastically reduce the Docker image size.</p><h3>The root of this problem</h3><p>The <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Java Platform Module System (JPMS)</a> was introduced with <a href="https://www.oracle.com/java/technologies/javase/9-all-relnotes.html">Java 9</a>. We can use JPMS to create our own custom JRE that is suitable for specific applications. For example, if an application does not use audio, image, or JavaBeans-related features, we can remove the java.desktop module entirely to free up space in our Docker image.</p><p>As previously stated, there is no separate JRE distribution from <a href="https://www.oracle.com/java/technologies/javase/11-relnote-issues.html">Java 11</a> onwards. That means that even if we just want to run a simple JVM-based application, we must install the entire JDK. This is due to the modularity introduced in Java 9. The main philosophy is that instead of providing a generic JRE that meets everyone’s needs, everyone should be able to create their own JRE. Many JDK image providers follow the same philosophy by omitting JRE distributions.</p><p>Unfortunately, using such images significantly increases the size of the Docker image.</p><p>To better understand this issue, let’s look at the basic Dockerfile required to run a simple JVM-based application.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine<br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]</pre><p>We’re using amazoncorretto:17-alpine as the base image here, and we’re copying the application jar file to it. At the end we run the jar file.</p><p>Let’s run this Dockerfile and see how big it is.</p><pre>ls -lh greetings/build/libs/greetings.jar | awk &#39;{print $5, $9}&#39;<br># 26M greetings/build/libs/greetings.jar<br><br>docker build -t greetings:jdk -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    jdk     ca39786a6f62   2 hours ago      361MB</pre><p>That is, the image size of 361 MB is quite large for a jar file of 26 MB, isn’t it? So, how can we make it smaller?</p><h3>The Solution</h3><p>Along with modularity, Java 9 includes a tool called <a href="https://docs.oracle.com/javase/9/tools/jlink.htm">jlink</a>. The main purpose of this tool is to assist us in creating custom JRE based on our needs. This tool offers a few options for fine-tuning JRE and the required modules, but it also offers the option of creating a generic JRE that includes all of the modules.</p><h4>Custom JRE</h4><p>Let’s start with a look at the generic Docker image.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine as corretto-jdk<br><br># required for strip-debug to work<br>RUN apk add --no-cache binutils<br><br># Build small JRE image<br>RUN jlink \<br>         --add-modules ALL-MODULE-PATH \<br>         --strip-debug \<br>         --no-man-pages \<br>         --no-header-files \<br>         --compress=2 \<br>         --output /jre<br><br>FROM alpine:latest<br>ENV JAVA_HOME=/jre<br>ENV PATH=&quot;${JAVA_HOME}/bin:${PATH}&quot;<br><br>COPY --from=corretto-jdk /jre $JAVA_HOME<br><br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]</pre><p>Let’s go over this file quickly.</p><ul><li>In this case, we used Docker multi-staged builds.</li><li>We use the same amazoncorretto:17-alpine Docker image as the base image in the first stage.</li><li>Following that, we install binutils, which is required by the jlink tool. The jlink tool is then used to create a custom JRE. The most important part of this command is --add-modules ALL-MODULE-PATH, which adds all the modules to JRE. On the <a href="https://docs.oracle.com/javase/9/tools/jlink.htm">Oracle documentation page</a>, you can learn more about all of the options.</li><li>The alpine:latest image is used as the base image in the second stage.</li><li>Then we copy the newly created custom JRE from the previous stage.</li><li>Finally, we are running our application jar file.</li></ul><p>Let’s now build this new dockerfile and examine the image size.</p><pre>docker build -t greetings:jre -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    jre    d5f20dab834c   2 hours ago      123MB</pre><p>That is the new image size is only 123 MB, which is nearly a third of the original image size, and this includes all modules.</p><p>Can we further reduce the size by only including the modules that are required? Yes, but the main question is how to determine which modules are required for the application to function properly.</p><h4>Slim JRE</h4><p>We can use the <a href="https://docs.oracle.com/javase/9/tools/jdeps.htm#JSWOR690">jdeps</a> command to determine the necessary modules. jdeps was first introduced in <a href="https://www.oracle.com/java/technologies/javase/8all-relnotes.html">Java 8</a> to examine dependencies in an application. Additionally, jdeps can discover every Java module that every library dependency uses. Before running the jdeps command, we must extract the jar file in order for it to function properly.</p><pre>unzip ./greetings/build/libs/greetings.jar -d temp<br><br>jdeps \<br>  --print-module-deps \<br>  --ignore-missing-deps \<br>  --recursive \<br>  --multi-release 17 \<br>  --class-path=&quot;./temp/BOOT-INF/lib/*&quot; \<br>  --module-path=&quot;./temp/BOOT-INF/lib/*&quot; \<br>  ./greetings/build/libs/greetings.jar<br><br># The output will look like following<br># java.base,java.compiler,java.desktop,java.instrument,java.management,java.naming,java.prefs,java.rmi,java.scripting,java.security.jgss,java.sql,jdk.httpserver,jdk.jfr,jdk.unsupported<br><br>rm -rf temp</pre><p>As you can see, we first extract the application jar file to a temporary directory before running the jdeps command with few <a href="https://docs.oracle.com/javase/9/tools/jdeps.htm">configuration options</a>. Finally, we remove the temporary directory.</p><blockquote>Note: jdeps will not be able to print required modules used by Reflection. For example, if application contains spring security, we need to add jdk.crypto.ec and jdk.crypto.cryptoki module manually.</blockquote><p>Now we’ll replace ALL-MODULE-PATH with the list printed by jdeps.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine as corretto-jdk<br><br># required for strip-debug to work<br>RUN apk add --no-cache binutils<br><br># Build small JRE image<br>RUN jlink \<br>         --verbose \<br>         --add-modules java.base,java.compiler,java.desktop,java.instrument,java.management,java.naming,java.prefs,java.rmi,java.scripting,java.security.jgss,java.sql,jdk.httpserver,jdk.jfr,jdk.unsupported,jdk.crypto.ec,jdk.crypto.cryptoki \<br>         --strip-debug \<br>         --no-man-pages \<br>         --no-header-files \<br>         --compress=2 \<br>         --output /jre<br><br>FROM alpine:latest<br>ENV JAVA_HOME=/jre<br>ENV PATH=&quot;${JAVA_HOME}/bin:${PATH}&quot;<br><br>COPY --from=corretto-jdk /jre $JAVA_HOME<br><br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]<br></pre><p>Let’s now build this new dockerfile and examine the image size.</p><pre>docker build -t greetings:slimjre -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    slimjre    450a64815cb3   46 minutes ago   89.8MB</pre><p>That is the new image size is only 90 MB, which is nearly a quarter of the original image size. Isn’t that preferable?</p><h4>Problem with Slim JRE and how to fix it</h4><p>We knew from previous results that slim JRE is superior to generic JRE. However, the slim JRE has a minor flaw. If the application is still in development, we may need to make frequent changes to our Dockerfile. Also, because we are changing the Dockerfile, Docker may not be able to reuse all of the layers.</p><h4>Automated Slim JRE</h4><p>If you continue to rely on using the slim JRE, we can at least automate the above process to make our lives a little easier. To automate the process, see the following GitHub gist:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f85efed2e5e0c531efcabc0570c24623/href">https://medium.com/media/f85efed2e5e0c531efcabc0570c24623/href</a></iframe><h3>Final Thoughts</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pKdmS4ej4EwFa4qGEwhVFA.png" /><figcaption>image size comparison</figcaption></figure><p>As you can see, we were able to reduce the image size by nearly three times with minimal effort. We have two alternatives.</p><ul><li>Slim JRE, the image size is extremely small, and it contains only the required Java module, which may necessitate frequent updates to the dockerfile, and Docker may be unable to reuse layers across projects.</li><li>Generic JRE, the image size of the generic JRE is slightly larger than that of the slim JRE, but it contains all of the Java modules.</li></ul><p>It is up to you to determine which JRE is best suited for your application. However, with either option, you will be able to drastically reduce the image size.</p><p><em>Note: Slim JRE concepts is getting used in </em><a href="https://github.com/otto-de/gitactionboard"><em>gitactionboard</em></a><em>, you can find the size difference on </em><a href="https://hub.docker.com/r/ottoopensource/gitactionboard/tags"><em>docker page</em></a><em>.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=459ec87b95d8" width="1" height="1" alt=""><hr><p><a href="https://blog.devops.dev/how-to-reduce-jvm-docker-image-size-by-at-least-60-459ec87b95d8">How to reduce JVM docker image size by at least 60%</a> was originally published in <a href="https://blog.devops.dev">DevOps.dev</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Is it the era of mono-repo?]]></title>
            <link>
                https://medium.com/@suman.maity112/is-it-the-era-of-mono-repo-671e6dee387?source=rss-92eeb3145de9------2
            </link>
            <guid isPermaLink="false">https://medium.com/p/671e6dee387</guid>
            <category><![CDATA[version-control]]></category>
            <category><![CDATA[multi-repo]]></category>
            <category><![CDATA[monorepo]]></category>
            <dc:creator><![CDATA[Suman Maity]]></dc:creator>
            <pubDate>Mon, 07 Nov 2022 08:11:46 GMT</pubDate>
            <atom:updated>2022-11-07T08:11:46.975Z</atom:updated>
            <content:encoded>
                <![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/846/1*3_jFMXz-0YlWjgoECgRk3A.png" /><figcaption>mono-repo heading</figcaption></figure><h3>What exactly is mono-repo?</h3><p>A mono-repository is a version-controlled repository that contains many related but independent projects. These can be managed by the same team or multiple teams.<br>Mono-repos are sometimes called “monolithic repositories” but let’s not get confused with <a href="https://en.wikipedia.org/wiki/Monolithic_application">monolithic software architecture</a>.</p><h3>What exactly is multi-repo?</h3><p>When a project receives its own version-controlled repository, it is called multi-repo structure, which is the exact opposite of mono-repo. Currently, the majority of developers uses multi-repo structure to maintain their projects.</p><h3>What are the advantages of mono-repo?</h3><p>Monorepo has many advantages, but I’ll just mention a few here:</p><ul><li><strong>Consistency</strong>: Because all of the projects are stored in the same repository, we can easily enforce the same coding style across all of them.</li><li><strong>Simpler dependency management</strong>: Using a modern dependency management tool makes it incredibly easy and simple to distribute dependencies among all the projects. Additionally, the package download for each project will be optimised depending on the package manager. Indirectly, the dependency tree will be simpler and cleaner.</li><li><strong>Easy patch management</strong>: Since all of the shared dependencies are in one place, we can quickly upgrade all of the projects’ versions of them. This saves us a lot of time, which allows us to perform more exciting work.</li><li><strong>Easy onboarding process</strong>: When a new member joins the team, it becomes simpler for them to understand the code and business flow as all the code is in the same repository.</li><li><strong>Unified build process</strong>: We can easily reuse the build process across projects.</li><li><strong>Easy global refactoring</strong>: We can easily refactor connected business flow across projects with the help of IDE.</li></ul><h3>What are the drawbacks of mono-repo?</h3><p>With lots of benefits, monorepo has a couple of drawbacks. Those are as follows:</p><ul><li><strong>Large codebase</strong>: The codebase eventually grows very huge because all the projects are kept in the same repository.</li><li><strong>Lengthy CI/CD process</strong>: (<em>Can be managed by advanced build tools.</em>) As all the projects are in the same repository, sometimes we need to unnecessarily build and test projects that do not have any code changes. It increases the code-to-production time.</li><li><strong>Heavy version control history</strong>: With a large codebase, version control history also becomes very heavy. It takes a long time to initially clone the repository on the local development system. It also creates issues when we are trying to find a <strong>bad</strong> commit.</li><li><strong>Learning curve</strong>: Once the codebase becomes large, it might impact the learning curve of a new team member.</li></ul><h3>How can you move from multi-repo to mono-repo?</h3><p>After knowing both the side of mono-repo structure, if you want to switch from multi-repo to mono-repo; all you have to do is move the relevant projects to the new repository. In this new repository, each project can have its own folder. Once every project has been migrated to a single repository, attempt to move shared dependencies, configurations, and CI/CD workflows to the root level. Test your application once it is complete to ensure that every feature works as expected.. If everything works fine, then voila! You have successfully created a mono-repo project structure 🎊👏.</p><h3>Best practices for mono-repo project structure</h3><p>Mono-repo makes a couple of things a little more complex than usual multi-repo projects, but if we keep the following points in mind, life can be a little simpler:</p><ul><li><strong>Invest in tools: </strong>you need to find and use suitable tools to manage monorepo. For example, <a href="https://lerna.js.org/">Lerna</a> makes it very easy to manage Node.js mono-repo projects. There are other tools like <a href="https://bazel.build/">Bazel</a>, <a href="https://buck.build/">Buck</a>, etc. that support multiple languages.</li><li><strong>Add proper tests</strong>: Add multiple levels of automated tests (unit tests, integration tests, architecture fitness tests, etc.) to keep the main branch clean.</li><li><strong>Better CI/CD process</strong>: With better and faster CI/CD, the code-to-production time issue can also be minimised. Therefore, we have to use suitable and modern CI/CD.</li></ul><h3>Conclusion</h3><p>As you can see, monorepo has lots of benefits and drawbacks. Now, if your question is, “Should I use Monorepo for real-life projects?” Then the simple answer is, “It depends.” 😅. There is no straight answer for this question. For some teams, it might be better to start with mono-repo over multi-repo or vice versa. It doesn’t matter what we choose; it can be changed in the future. We have to keep in mind that it’s not about the technology; it’s about communication and collaboration among team members.</p><p><em>PS: I hope you’ve enjoyed it, and if you’ve found it useful, please feel free to share it with others or leave a comment.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=671e6dee387" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Migrate terraform resource from one project to another]]></title>
            <link>
                https://medium.com/@suman.maity112/migrate-terraform-resource-from-one-project-to-another-61d0c347419a?source=rss-92eeb3145de9------2
            </link>
            <guid isPermaLink="false">https://medium.com/p/61d0c347419a</guid>
            <category><![CDATA[state-migration]]></category>
            <category><![CDATA[terraform-state-mv]]></category>
            <category><![CDATA[tfstate]]></category>
            <category><![CDATA[terraform]]></category>
            <dc:creator><![CDATA[Suman Maity]]></dc:creator>
            <pubDate>Thu, 08 Sep 2022 07:27:46 GMT</pubDate>
            <atom:updated>2022-09-08T07:27:46.790Z</atom:updated>
            <content:encoded>
                <![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/970/1*5fUQzV5GianB3J20GuHjOg.png" /></figure><p>As part of this article let’s try to understand how can we safely migrate Terraform state from one project to another. But before we start, let us understand when do we need this state migration.</p><h4>When do we need State migration ?</h4><p>Terraform state migration can be required mainly for these 2 reasons —</p><ol><li>we want to <strong>rename the</strong> <strong>terraform resource without changing the actual resource</strong> on the cloud</li><li>Due to <strong>project architecture change</strong></li></ol><h3>How can we migrate terraform remote state ?</h3><p>Terraform state migration can be done in multiple ways —</p><ol><li>Delete the existing state using terraform state rm and import the existing resource using terraform state import command in the new place.</li><li>Make use of terraform state mv command.</li></ol><p>The recommended and preferred way is using terraform state mv command.</p><h4>How can we make use of terraform state mv command ?</h4><p>For <em>1st scenario</em>, where we just want to change the <strong>terraform resource name without changing the actual resource </strong>on the same project, it’s pretty straight forward. We can just run the following command to do so</p><p>terraform state mv &quot;aws_secretsmanager_secret.username&quot; &quot;aws_secretsmanager_secret.github_username&quot;</p><p>But for <em>2nd scenario</em>, the state migration becomes little tricky as it is across two different project/workspace. To be able to safely migrate the state, we need to follow the following steps —</p><ol><li>Move the infrastructure code from source project (example: <em>hello_earth</em>) to destination project (example: <em>hello_mars</em>)</li><li>Pull existing state for source project (<em>hello_earth</em>). We can use terraform state pull command and store the output into a file ( hello_earth.tfstate ). It’s suggested to create a backup file (hello_earth_backup.tfstate) as well.</li><li>Pull existing state for destination project (<em>hello_mars</em>). We can use terraform state pull and store the output into a file ( hello_mars.tfstate ). It’s suggested create a backup file (hello_mars_backup.tfstate) as well.</li><li>Figure out the terraform resource ids which you want to migrate by using terraform state list on source project (<em>hello_earth</em>).</li><li>Figure out the terraform resource ids in destination project (<em>hello_mars</em>). This can be done by either running terraform plan or can be generated manually. Most of the time it’s &lt;terraform resource type&gt;.&lt;terraform resource name&gt;</li><li>Once you are done with the above steps, we can start on actual migration. terraform state mv -state=&quot;/Users/john/hello_earth/hello_earth.tfstate&quot; <br> -state-out=&quot;/Users/john/hello_mars/hello_mars.tfstate&quot; &quot;aws_secretsmanager_secret.username&quot; &quot;aws_secretsmanager_secret.github_username&quot;</li><li>Push the newly modified state file for destination project (<em>hello_mars</em>) by using terraform state push &quot;/Users/john/hello_mars/hello_mars.tfstate&quot;</li><li>Push the newly modified state file for source project (<em>hello_earth</em>) by using terraform state push &quot;/Users/john/hello_earth/hello_earth.tfstate&quot;. We need to do it as we moved terraform state from the source file ( hello_earth.tfstate ) to destination file ( hello_mars.tfstate ) i.e. it’s modified.</li><li>Run terraform plan on both the project to verify terraform state move does not any side-effect. Ideally, it should display <em>no changes found. </em>In case, if it displays some changes and changes are not legit, you can always push the backup states and start from the scratch (<em>step 1</em>) without any side effect.</li><li>Once you verify the changes, push the modified code for both the projects to the remote (example — Github, BitBucket etc)</li></ol><blockquote>Note 1: You may need to run step 6 multiple times depends on how many resource(s) you want to migrate.</blockquote><blockquote>Note 2: Until state push happens in step 7 and step 8, there is no side effect or changes in remote state. If you make any mistake, you can always start fresh without any side effect on the remote state.</blockquote><p>Terraform state migration process is always little tricky and risky. I hope this article was able to make the process little simpler than previous.</p><p>PS: I hope you’ve enjoyed it, and if you’ve found it useful, please feel free to share with others or leave a comment 😃.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=61d0c347419a" width="1" height="1" alt="">]]></content:encoded>
        </item>
    </channel>
</rss>
